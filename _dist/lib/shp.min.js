/*! ****************************************************************************
 * SHP v0.0.3
 *
 * A library for reading Natural Earth's SHP files.
 * (you can download it from npm or github repositories)
 * Copyright (c) 2019 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
 * Released under the MIT license. You may obtain a copy of the License
 * at: http://www.opensource.org/licenses/mit-license.php).
 * ************************************************************************** */
!function(e,r){"use strict";"function"==typeof define&&define.amd?define([""],r):"object"==typeof exports?(module.exports=r(e),null===e.SHP&&(e.SHP=r(e))):e.SHP=r(e)}(this,e=>{"use strict";let r,t={src:{shp:{},lib:{_:{}},internal:{load:{},dbf:{},shp:{}}},extend:function(e,r){for(var t=Object.keys(r),n=0;n<t.length;n++)e[t[n]]=r[t[n]]}};return function(){const n=t.src.internal.load,o=t.src.internal.dbf,s=t.src.internal.shp,a=e.SHP;let d;r=function(){const e=Object.create(d);return e._dbf={buf:null,header:null,fieldDescriptorArray:null},e._shp={buf:null,header:null},e},r.VERSION="0.0.3",r.noConflict=function(){return e.SHP=a,this},d={_getDbfRecord(e){return o.getRecord(this._dbf,e)},_getDbfHeader(){return this._dbf.header},_getDbfFieldDescriptor(){return this._dbf.fieldDescriptorArray},_getShpRecord(e){return s.getRecord(this._shp,e)},_getShpHeader(){return this._shp.header},load(e,r){return new Promise(t=>{n.load(e,e=>{[this._dbf.buf]=e,[,this._shp.buf]=e,[,,this._source]=e,o.decode(this._dbf),s.decode(this._shp),t(),r&&r()})})},getCollection(){const{header:e}=this._shp,r=this._getDbfRecord(),t=this._getShpRecord(),n={bbox:[e.Xmin,e.Ymin,e.Xmax,e.Ymax],type:"FeatureCollection",features:[]};for(let e=0;e<this._dbf.header.numberOfRecords;e++)n.features[e]={type:"Feature",properties:r[e],geometry:{type:t[e].type,coordinates:t[e].coordinates}};return n},getFeature(e){if("number"!=typeof e||e%1!=0||e<=0||e>this._dbf.header.numberOfRecords)throw new Error(`The record Number "${e}" does not match!`);const r=s.getRecord(this._shp,e);return{type:"Feature",properties:o.getRecord(this._dbf,e),geometry:{type:r.type,coordinates:r.coordinates}}},getSource(){return{name:this._source.db,version:this._source.version}}}}(),function(){const e={readString(e,r,t){let n="";for(let o=r;o<t;o++)n+=String.fromCharCode(e[o]);return n.replace(/\u0000/g,"")},readUTF8String:(e,r,t)=>(function(e,r,t){const n=t-r;let o,s,a,d="",i=0;for(;i<n;)if(o=e[r+i],o<128)d+=String.fromCharCode(o),i+=1;else if(o>191&&o<224){if(i+1>=n)throw new Error("UTF-8 Decode failed. Two byte character was truncated.");s=e[r+i+1],d+=String.fromCharCode((31&o)<<6|63&s),i+=2}else{if(i+2>=n)throw new Error("UTF-8 Decode failed. Two byte character was truncated.");s=e[r+i+1],a=e[r+i+2],d+=String.fromCharCode((15&o)<<12|(63&s)<<6|63&a),i+=3}return d})(e,r,t),readUInt8:(e,r)=>e[r],readUInt16LE:(e,r)=>256*e[r+1]+e[r],readUInt32LE:(e,r)=>e[r+3]*2**32+65536*e[r+2]+256*e[r+1]+e[r],readUInt32BE:(e,r)=>e[r]*2**32+65536*e[r+1]+256*e[r+2]+e[r+3],readDoubleLE(e,r){const t=new ArrayBuffer(8),n=new DataView(t);for(let t=0;t<8;t++)n.setUint8(7-t,e[r+t]);return n.getFloat64(0)}};t.extend(t.src.lib._,e)}(),function(){const e=function(e,r,t){const n=new window.XMLHttpRequest;switch(n.onreadystatechange=function(){let e;if(4===n.readyState)if(200===n.status||0===n.status)switch(r){case"json":t(!1,n,n.responseText);break;case"bin":e=new Uint8Array(n.response),t(!1,n,e);break;default:throw new Error(`load: the type "${r}" is unknown!`)}else t(!0,n)},r){case"json":n.open("GET",e,!0),n.send(null);break;case"bin":n.open("GET",e,!0),n.responseType="arraybuffer",n.send(null);break;default:throw new Error(`_load: the type "${r}" is unknown!`)}};const r={load(r,t){!function(r,t){const n=r.split("/").pop();e(`${r}/${n}.dbf`,"bin",(o,s,a)=>{e(`${r}/${n}.shp`,"bin",(o,s,d)=>{e(`${r}/${n}.VERSION.txt`,"json",(e,r,o)=>{t([a,d,{db:n,version:o.replace(/[^\d.]/gi,"")}])})})})}(r,t)}};t.extend(t.src.internal.load,r)}(),function(){const{_:e}=t.src.lib;function r(r,t,n,o){const s={};let a,d=t.startRecordSection+t.numberOfBytesInRecord*o;if(32!==e.readUInt8(r,d)&&42!==e.readUInt8(r,d))throw new Error(`The first byte of the record should be "0x20" or "0x2A" instead of: ${e.readUInt8(r,d).toString(16)}`);d+=1;for(let o=0;o<t.numberOfFieldsArray;o++){switch(a=e.readUTF8String(r,d,d+n[o].length),n[o].type){case"C":s[n[o].name]=a.replace(/^\s+|\s+$/g,"");break;case"D":throw new Error('Field Data Type "D" not processed yet!');case"N":s[n[o].name]=parseInt(a.replace(/^\s+|\s+$/g,""),10);break;case"F":s[n[o].name]=parseFloat(a);break;case"L":throw new Error('Field Data Type "L" not processed yet!');case"M":throw new Error('Field Data Type "M" not processed yet!');default:throw new Error(`Field Data Type ${n[o].type} is not supported!`)}d+=n[o].length}return s}const n={decode(r){r.header=function(r){const t={dbaseVersion:e.readUInt8(r.buf,0),numberOfRecords:e.readUInt32LE(r.buf,4),numberOfBytesInHeader:e.readUInt16LE(r.buf,8),numberOfBytesInRecord:e.readUInt16LE(r.buf,10),bytes12_14:"Reserved bytes.",bytes15_27:"Reserved for dBASE III PLUS on a LAN.",bytes28_31:"Reserved bytes.",bytes32_n:"Field Descriptor Array",terminator:"0x0D stored as the Field Descriptor terminator.",numberOfFieldsArray:0,startRecordSection:0};return t.numberOfFieldsArray=(t.numberOfBytesInHeader-1)/32-1,t.startRecordSection=t.numberOfBytesInHeader,t}(r),r.fieldDescriptorArray=function(r,t){const n=[];let o=32;for(let s=0;s<t.numberOfFieldsArray;s++)n[s]={},n[s].name=e.readString(r,o,o+11),n[s].type=String.fromCharCode(e.readUInt8(r,o+11)),n[s].dataAddress=e.readUInt32LE(r,o+12),n[s].length=e.readUInt8(r,o+16),n[s].count=e.readUInt8(r,o+17),n[s].workArreaID=e.readUInt8(r,o+20),n[s].flag=e.readUInt8(r,o+23),o+=32;if(13!==e.readUInt8(r,o))throw new Error("Field Descriptor terminator 0x0D not found!");return n}(r.buf,r.header)},getRecord:(e,t)=>(function(e,t){const n=[];if("[object Number]"!==Object.prototype.toString.call(t)){for(let t=0;t<e.header.numberOfRecords;t++)n[t]=r(e.buf,e.header,e.fieldDescriptorArray,t);return n}if(t%1==0&&t>0&&t<=e.header.numberOfRecords){return r(e.buf,e.header,e.fieldDescriptorArray,t-1)}return null})(e,t)};t.extend(t.src.internal.dbf,n)}(),function(){const{_:e}=t.src.lib,r=100,n=8;function o(r,t){return[e.readDoubleLE(r,t+n+12),e.readDoubleLE(r,t+n+4)]}function s(r,t){const o=[];let s,a,d;e.readDoubleLE(r,t+n+4),e.readDoubleLE(r,t+n+12),e.readDoubleLE(r,t+n+20),e.readDoubleLE(r,t+n+28);const i=e.readUInt32LE(r,t+n+36),c=e.readUInt32LE(r,t+n+40),u=(e.readUInt32LE(r,t+n+44),t+n+44+4*i);for(let h=0;h<i;h++){s=e.readUInt32LE(r,t+n+44+4*h),a=h+1<i?e.readUInt32LE(r,t+n+44+4*(h+1))-1:c-1,d=[];for(let t=s;t<=a;t++)d[t-s]=[e.readDoubleLE(r,u+16*t+8),e.readDoubleLE(r,u+16*t)];o.push(d)}return o}function a(t,a){const d=function(t,a){const d=[];let i=r;for(let r=0;i<a.fileLength;r++){switch(d[r]={recordNumber:e.readUInt32BE(t,i),contentLength:e.readUInt32BE(t,i+4),shape:e.readUInt32LE(t,i+n),type:"",coordinates:[]},d[r].shape){case 0:throw new Error('The Shape Type "Null Shape" is not supported yet!');case 1:d[r].type="Point",d[r].coordinates=o(t,i);break;case 3:d[r].type="PolyLine",d[r].coordinates=s(t,i);break;case 5:d[r].type="Polygon",d[r].coordinates=s(t,i);break;case 8:throw new Error('The Shape Type "MultiPoint" is not supported yet!');case 11:throw new Error('The Shape Type "PointZ" is not supported yet!');case 13:throw new Error('The Shape Type "PolyLineZ" is not supported yet!');case 15:throw new Error('The Shape Type "PolygonZ" is not supported yet!');case 18:throw new Error('The Shape Type "MultiPointZ" is not supported yet!');case 21:throw new Error('The Shape Type "PointM" is not supported yet!');case 23:throw new Error('The Shape Type "PolyLineM" is not supported yet!');case 25:throw new Error('The Shape Type "PolygonM" is not supported yet!');case 28:throw new Error('The Shape Type "MultiPointM" is not supported yet!');case 31:throw new Error('The Shape Type "MultiPatch" is not supported yet!');default:throw new Error(`The Shape Type "${d[r].shape}" is unknown!`)}i+=2*d[r].contentLength+n}return d}(t.buf,t.header);if(!a)return d;if(a%1!=0||a<1)throw new Error(`This record number "${a}" does not match!`);return d[a-1]?d[a-1]:null}const d={decode(r){r.header=function(r){const t={code:e.readUInt32BE(r,0),byte4:"Unused",byte8:"Unused",byte12:"Unused",byte16:"Unused",byte20:"Unused",fileLength:2*e.readUInt32BE(r,24),version:e.readUInt32LE(r,28),shape:e.readUInt32LE(r,32),Xmin:e.readDoubleLE(r,36),Ymin:e.readDoubleLE(r,44),Xmax:e.readDoubleLE(r,52),Ymax:e.readDoubleLE(r,60),Zmin:e.readDoubleLE(r,68),Zmax:e.readDoubleLE(r,76),Mmin:e.readDoubleLE(r,84),Mmax:e.readDoubleLE(r,92)};if(9994!==t.code)throw new Error(`This is not a SHP file! The first four bytes are: "${t.code}" instead of "9994"`);if(0!==t.Zmin||0!==t.Zmax)throw new Error("SHP files with Z type != zero are not supported!");if(0!==t.Mmin||0!==t.Mmax)throw new Error("SHP files with points having M Measure are not supported!");return t}(r.buf)},getRecord:(e,r)=>a(e,r)};t.extend(t.src.internal.shp,d)}(),r});