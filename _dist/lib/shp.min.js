/*! ****************************************************************************
 * SHP v0.0.1
 *
 * A library for reading Natural Earth's SHP files.
 * (you can download it from npm or github repositories)
 * Copyright (c) 2019 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
 * Released under the MIT license. You may obtain a copy of the License
 * at: http://www.opensource.org/licenses/mit-license.php).
 * ************************************************************************** */
!function(e,r){"use strict";"function"==typeof define&&define.amd?define([""],r):"object"==typeof exports?(module.exports=r(e),e.SHP||(e.SHP=r(e))):e.SHP=r(e)}(this,e=>{"use strict";let r,t;const o={};return t={readString(e,r,t){let o="";for(let n=r;n<t;n++)o+=String.fromCharCode(e[n]);return o.replace(/\u0000/g,"")},readUTF8String:(e,r,t)=>(function(e,r,t){const o=t-r;let n,a,s,d="",i=0;for(;i<o;)if((n=e[r+i])<128)d+=String.fromCharCode(n),i+=1;else if(n>191&&n<224){if(i+1>=o)throw new Error("UTF-8 Decode failed. Two byte character was truncated.");a=e[r+i+1],d+=String.fromCharCode((31&n)<<6|63&a),i+=2}else{if(i+2>=o)throw new Error("UTF-8 Decode failed. Two byte character was truncated.");a=e[r+i+1],s=e[r+i+2],d+=String.fromCharCode((15&n)<<12|(63&a)<<6|63&s),i+=3}return d})(e,r,t),readUInt8:(e,r)=>e[r],readUInt16LE:(e,r)=>256*e[r+1]+e[r],readUInt32LE:(e,r)=>e[r+3]*2**32+65536*e[r+2]+256*e[r+1]+e[r],readUInt32BE:(e,r)=>e[r]*2**32+65536*e[r+1]+256*e[r+2]+e[r+3],readDoubleLE(e,r){const t=new ArrayBuffer(8),o=new DataView(t);for(let t=0;t<8;t++)o.setUint8(7-t,e[r+t]);return o.getFloat64(0)}},function(){const e=function(e,r,t){const o=new XMLHttpRequest;switch(o.onreadystatechange=function(){let e;if(4===o.readyState)if(200===o.status||0===o.status)switch(r){case"json":t(!1,o,o.responseText);break;case"bin":e=new Uint8Array(o.response),t(!1,o,e);break;default:throw new Error(`load: the type "${r}" is unknown!`)}else t(!0,o)},r){case"json":o.open("GET",e,!0),o.send(null);break;case"bin":o.open("GET",e,!0),o.responseType="arraybuffer",o.send(null);break;default:throw new Error(`_load: the type "${r}" is unknown!`)}};o.Util={load(r,t){!function(r,t){const o=r.split("/").pop();e(`${r}/${o}.dbf`,"bin",(n,a,s)=>{e(`${r}/${o}.shp`,"bin",(n,a,d)=>{e(`${r}/${o}.VERSION.txt`,"json",(e,r,n)=>{t([s,d,{db:o,version:n.replace(/[^\d.]/gi,"")}])})})})}(r,t)}}}(),function(){function e(e,r,o,n){const a={};let s,d=r.startRecordSection+r.numberOfBytesInRecord*n;if(32!==t.readUInt8(e,d)&&42!==t.readUInt8(e,d))throw new Error(`The first byte of the record should be "0x20" or "0x2A" instead of: ${t.readUInt8(e,d).toString(16)}`);d+=1;for(let n=0;n<r.numberOfFieldsArray;n++){switch(s=t.readUTF8String(e,d,d+o[n].length),o[n].type){case"C":a[o[n].name]=s.replace(/^\s+|\s+$/g,"");break;case"D":throw new Error('Field Data Type "D" not processed yet!');case"N":a[o[n].name]=parseInt(s.replace(/^\s+|\s+$/g,""),10);break;case"F":a[o[n].name]=parseFloat(s);break;case"L":throw new Error('Field Data Type "L" not processed yet!');case"M":throw new Error('Field Data Type "M" not processed yet!');default:throw new Error(`Field Data Type ${o[n].type} is not supported!`)}d+=o[n].length}return a}o.DBF={decode(e){e.header=function(e){const r={dbaseVersion:t.readUInt8(e.buf,0),numberOfRecords:t.readUInt32LE(e.buf,4),numberOfBytesInHeader:t.readUInt16LE(e.buf,8),numberOfBytesInRecord:t.readUInt16LE(e.buf,10),bytes12_14:"Reserved bytes.",bytes15_27:"Reserved for dBASE III PLUS on a LAN.",bytes28_31:"Reserved bytes.",bytes32_n:"Field Descriptor Array",terminator:"0x0D stored as the Field Descriptor terminator.",numberOfFieldsArray:0,startRecordSection:0};return r.numberOfFieldsArray=(r.numberOfBytesInHeader-1)/32-1,r.startRecordSection=r.numberOfBytesInHeader,r}(e),e.fieldDescriptorArray=function(e,r){const o=[];let n=32;for(let a=0;a<r.numberOfFieldsArray;a++)o[a]={},o[a].name=t.readString(e,n,n+11),o[a].type=String.fromCharCode(t.readUInt8(e,n+11)),o[a].dataAddress=t.readUInt32LE(e,n+12),o[a].length=t.readUInt8(e,n+16),o[a].count=t.readUInt8(e,n+17),o[a].workArreaID=t.readUInt8(e,n+20),o[a].flag=t.readUInt8(e,n+23),n+=32;if(13!==t.readUInt8(e,n))throw new Error("Field Descriptor terminator 0x0D not found!");return o}(e.buf,e.header)},getRecord:(r,t)=>(function(r,t){const o=[];if("[object Number]"!==Object.prototype.toString.call(t)){for(let t=0;t<r.header.numberOfRecords;t++)o[t]=e(r.buf,r.header,r.fieldDescriptorArray,t);return o}if(t%1==0&&t>0&&t<=r.header.numberOfRecords){return e(r.buf,r.header,r.fieldDescriptorArray,t-1)}return null})(r,t)}}(),function(){const e=100,r=8;function n(e,o){return[t.readDoubleLE(e,o+r+12),t.readDoubleLE(e,o+r+4)]}function a(e,o){const n=[];let a,s,d;t.readDoubleLE(e,o+r+4),t.readDoubleLE(e,o+r+12),t.readDoubleLE(e,o+r+20),t.readDoubleLE(e,o+r+28);const i=t.readUInt32LE(e,o+r+36),u=t.readUInt32LE(e,o+r+40),c=(t.readUInt32LE(e,o+r+44),o+r+44+4*i);for(let h=0;h<i;h++){a=t.readUInt32LE(e,o+r+44+4*h),s=h+1<i?t.readUInt32LE(e,o+r+44+4*(h+1))-1:u-1,d=[];for(let r=a;r<=s;r++)d[r-a]=[t.readDoubleLE(e,c+16*r+8),t.readDoubleLE(e,c+16*r)];n.push(d)}return n}function s(o,s){const d=function(o,s){const d=[];let i=e;for(let e=0;i<s.fileLength;e++){switch(d[e]={recordNumber:t.readUInt32BE(o,i),contentLength:t.readUInt32BE(o,i+4),shape:t.readUInt32LE(o,i+r),type:"",coordinates:[]},d[e].shape){case 0:throw new Error('The Shape Type "Null Shape" is not supported yet!');case 1:d[e].type="Point",d[e].coordinates=n(o,i);break;case 3:d[e].type="PolyLine",d[e].coordinates=a(o,i);break;case 5:d[e].type="Polygon",d[e].coordinates=a(o,i);break;case 8:throw new Error('The Shape Type "MultiPoint" is not supported yet!');case 11:throw new Error('The Shape Type "PointZ" is not supported yet!');case 13:throw new Error('The Shape Type "PolyLineZ" is not supported yet!');case 15:throw new Error('The Shape Type "PolygonZ" is not supported yet!');case 18:throw new Error('The Shape Type "MultiPointZ" is not supported yet!');case 21:throw new Error('The Shape Type "PointM" is not supported yet!');case 23:throw new Error('The Shape Type "PolyLineM" is not supported yet!');case 25:throw new Error('The Shape Type "PolygonM" is not supported yet!');case 28:throw new Error('The Shape Type "MultiPointM" is not supported yet!');case 31:throw new Error('The Shape Type "MultiPatch" is not supported yet!');default:throw new Error(`The Shape Type "${d[e].shape}" is unknown!`)}i+=2*d[e].contentLength+r}return d}(o.buf,o.header);if(!s)return d;if(s%1!=0||s<1)throw new Error(`This record number "${s}" does not match!`);return d[s-1]?d[s-1]:null}o.SH={decode(e){e.header=function(e){const r={code:t.readUInt32BE(e,0),byte4:"Unused",byte8:"Unused",byte12:"Unused",byte16:"Unused",byte20:"Unused",fileLength:2*t.readUInt32BE(e,24),version:t.readUInt32LE(e,28),shape:t.readUInt32LE(e,32),Xmin:t.readDoubleLE(e,36),Ymin:t.readDoubleLE(e,44),Xmax:t.readDoubleLE(e,52),Ymax:t.readDoubleLE(e,60),Zmin:t.readDoubleLE(e,68),Zmax:t.readDoubleLE(e,76),Mmin:t.readDoubleLE(e,84),Mmax:t.readDoubleLE(e,92)};if(9994!==r.code)throw new Error(`This is not a SHP file! The first four bytes are: "${r.code}" instead of "9994"`);if(0!==r.Zmin||0!==r.Zmax)throw new Error("SHP files with Z type != zero are not supported!");if(0!==r.Mmin||0!==r.Mmax)throw new Error("SHP files with points having M Measure are not supported!");return r}(e.buf)},getRecord:(e,r)=>s(e,r)}}(),function(){const{Util:t}=o,{DBF:n}=o,{SH:a}=o,s=e.SHP;let d;(r=function(){const e=Object.create(d);return e._dbf={buf:null,header:null,fieldDescriptorArray:null},e._shp={buf:null,header:null},e}).VERSION="0.0.1",r.noConflict=function(){return e.SHP=s,this},d={_getDbfRecord(e){return n.getRecord(this._dbf,e)},_getDbfHeader(){return this._dbf.header},_getDbfFieldDescriptor(){return this._dbf.fieldDescriptorArray},_getShpRecord(e){return a.getRecord(this._shp,e)},_getShpHeader(){return this._shp.header},load(e,r){return new Promise(o=>{t.load(e,e=>{[this._dbf.buf]=e,[,this._shp.buf]=e,[,,this._source]=e,n.decode(this._dbf),a.decode(this._shp),o(),r&&r()})})},getCollection(){const{header:e}=this._shp,r=this._getDbfRecord(),t=this._getShpRecord(),o={bbox:[e.Xmin,e.Ymin,e.Xmax,e.Ymax],type:"FeatureCollection",features:[]};for(let e=0;e<this._dbf.header.numberOfRecords;e++)o.features[e]={type:"Feature",properties:r[e],geometry:{type:t[e].type,coordinates:t[e].coordinates}};return o},getFeature(e){if("number"!=typeof e||e%1!=0||e<=0||e>this._dbf.header.numberOfRecords)throw new Error(`The record Number "${e}" does not match!`);const r=a.getRecord(this._shp,e);return{type:"Feature",properties:n.getRecord(this._dbf,e),geometry:{type:r.type,coordinates:r.coordinates}}},getSource(){return{name:this._source.db,version:this._source.version}}}}(),r});